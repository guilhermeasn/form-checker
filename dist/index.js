var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P((function(resolve){resolve(value)}))}return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.formChecker=formChecker;const helpers_1=require("./helpers");function formChecker(schema_1,data_1){return __awaiter(this,arguments,void 0,(function*(schema,data,language="en"){const result=Object.assign({},data),errors={},messages={};loop:for(let field in schema){const rules=schema[field];let value=data[field];"string"!=typeof value||rules.untrimmed||(value=value.trim());const onError=(error,customMessage)=>{var _a,_b;return errors[field]=error,messages[field]=null!==(_b=null!=customMessage?customMessage:null===(_a=rules.messages)||void 0===_a?void 0:_a[error])&&void 0!==_b?_b:(0,helpers_1.getDefaultMessage)(error,language),!0};if(rules.required&&(0,helpers_1.isEmpty)(value)){if("object"!=typeof rules.required){onError("required");continue loop}if("default"in rules.required){result[field]="function"==typeof rules.required.default?yield rules.required.default():rules.required.default;continue loop}if(rules.required.ifFilled){const fields=Array.isArray(rules.required.ifFilled)?rules.required.ifFilled:[rules.required.ifFilled];for(const field of fields)if(!(0,helpers_1.isEmpty)(data[field])){onError("required");continue loop}}if(rules.required.ifNotFilled){const fields=Array.isArray(rules.required.ifNotFilled)?rules.required.ifNotFilled:[rules.required.ifNotFilled];for(const field of fields)if((0,helpers_1.isEmpty)(data[field])){onError("required");continue loop}}}const befores=(0,helpers_1.normalizeArray)(rules.onBefore);for(let f of befores)value=yield f(value);if(rules.checked&&!value&&onError("checked"))continue loop;if(rules.equal&&(0,helpers_1.isNotEqual)(data[rules.equal],value)&&onError("equal"))continue loop;if("string"==typeof value||"number"==typeof value){const valueString=value.toString().trim();if(rules.min&&((0,helpers_1.isInvalidNumber)(valueString)||parseFloat(valueString)<rules.min)&&onError("min"))continue loop;if(rules.max&&((0,helpers_1.isInvalidNumber)(valueString)||parseFloat(valueString)>rules.max)&&onError("max"))continue loop;if(rules.minLength&&valueString.length<rules.minLength&&onError("minLength"))continue loop;if(rules.maxLength&&valueString.length>rules.maxLength&&onError("maxLength"))continue loop;const regs=(0,helpers_1.normalizeArray)(rules.regexp);for(let r of regs)if(!r.test(valueString)&&onError("regexp"))continue loop}const tests=(0,helpers_1.normalizeArray)(rules.test);for(let t of tests){const r=yield t(value);if(!0!==r){onError("test","string"==typeof r?r:void 0);continue loop}}const afters=(0,helpers_1.normalizeArray)(rules.onAfter);for(let f of afters)value=yield f(value);result[field]=value}return{isValid:0===Object.keys(errors).length,messages:messages,errors:errors,result:result}}))}exports.default=formChecker;