var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P((function(resolve){resolve(value)}))}return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.formChecker=formChecker;const errors_1=require("./errors");function formChecker(schema_1,data_1){return __awaiter(this,arguments,void 0,(function*(schema,data,language="en"){const isEmpty=value=>null==value||""===value.toString().trim(),isInvalidNumber=value=>isNaN(parseFloat(value)),isNotEqual=(a,b)=>a!==b,getDefaultMessage=error=>"string"==typeof language?errors_1.defaultMessages[language][error]:language[error],result=Object.assign({},data),errors={},messages={};loop:for(let field in schema){const rules=schema[field];let value=data[field];"string"!=typeof value||rules.untrimmed||(value=value.trim());const onError=error=>{var _a,_b;return errors[field]=error,messages[field]=null!==(_b=null===(_a=rules.messages)||void 0===_a?void 0:_a[error])&&void 0!==_b?_b:getDefaultMessage(error),!0};if(rules.required&&isEmpty(value)){if("object"!=typeof rules.required){onError("required");continue loop}if("default"in rules.required){result[field]="function"==typeof rules.required.default?yield rules.required.default():rules.required.default;continue loop}if(rules.required.ifFilled){const fields=Array.isArray(rules.required.ifFilled)?rules.required.ifFilled:[rules.required.ifFilled];for(const field of fields)if(!isEmpty(data[field])){onError("required");continue loop}}if(rules.required.ifNotFilled){const fields=Array.isArray(rules.required.ifNotFilled)?rules.required.ifNotFilled:[rules.required.ifNotFilled];for(const field of fields)if(isEmpty(data[field])){onError("required");continue loop}}}if(rules.onBefore){const funcs=Array.isArray(rules.onBefore)?rules.onBefore:[rules.onBefore];for(let f of funcs)value=yield f(value)}if((!rules.checked||value||!onError("checked"))&&!(rules.equal&&isNotEqual(data[rules.equal],value)&&onError("equal"))){if("string"==typeof value||"number"==typeof value){const valueString=value.toString().trim();if(rules.min&&(isInvalidNumber(valueString)||parseFloat(valueString)<rules.min)&&onError("min"))continue loop;if(rules.max&&(isInvalidNumber(valueString)||parseFloat(valueString)>rules.max)&&onError("max"))continue loop;if(rules.minLength&&valueString.length<rules.minLength&&onError("minLength"))continue loop;if(rules.maxLength&&valueString.length>rules.maxLength&&onError("maxLength"))continue loop;if(rules.regexp){const regs=Array.isArray(rules.regexp)?rules.regexp:[rules.regexp];for(let r of regs)if(!r.test(valueString)&&onError("regexp"))continue loop}}if(rules.test){const tests=Array.isArray(rules.test)?rules.test:[rules.test];for(let t of tests)if(!(yield t(value))&&onError("test"))continue loop}if(rules.onAfter){const funcs=Array.isArray(rules.onAfter)?rules.onAfter:[rules.onAfter];for(let f of funcs)value=yield f(value)}result[field]=value}}return{isValid:0===Object.keys(errors).length,messages:messages,errors:errors,result:result}}))}exports.default=formChecker;